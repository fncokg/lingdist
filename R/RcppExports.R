# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Compute edit distance between two strings
#'
#' Compute edit distance between two strings and get all possible alignment scenarios. Custom cost matrix is supported. Symbols separated by custom delimiters are supported.
#'
#' @param str1 String to be compared.
#' @param str2 String to be compared.
#' @param cost_mat Dataframe in squareform indicating the cost values when one symbol is deleted, inserted or substituted by another. Rownames and colnames are symbols. `cost_mat[char1,"_NULL_"]` indicates the cost value of deleting char1 and `cost_mat["_NULL_",char1]` is the cost value of inserting it. When an operation is not defined in the cost_mat, it is set 0 when the two symbols are the same, otherwise 1. See also [generate_default_cost_matrix()] to generate a default cost matrix.
#' @param delim The delimiter in `str1` and `str2` separating atomic symbols.
#' @param return_alignments Whether to return alignment details
#' @return A list containing a `distance` element storing the distance result. If `return_alignments` is TRUE, then an `alignments` element is present which is a list of dataframes with each storing a possible best alignment scenario.
#' @seealso [generate_default_cost_matrix()]
#' @examples
#' cost.mat <- data.frame()
#' dist <- string_edit_dist("leaf","leaves")$distance
#' res <- string_edit_dist("ph_l_i_z","p_l_i_s",cost_mat=cost.mat,delim="_")
#' alignments <- res$alignments
string_edit_dist <- function(str1, str2, cost_mat = NULL, delim = "", return_alignments = FALSE) {
    .Call(`_lingdist_string_edit_dist`, str1, str2, cost_mat, delim, return_alignments)
}

#' Compute edit distance between all row pairs of a dataframe
#'
#' Compute average edit distance between all row pairs of a dataframe, empty or NA cells are ignored. If all values in a row are not valid strings, all average distances involving this row is set to -1.
#'
#' @param data DataFrame with n rows and m columns indicating there are n languages or dialects to involve in the calculation and there are at most m words to base on, in which the rownames are the language ids.
#' @param cost_mat Dataframe in squareform indicating the cost values when one symbol is deleted, inserted or substituted by another. Rownames and colnames are symbols. `cost_mat[char1,"_NULL_"]` indicates the cost value of deleting char1 and `cost_mat["_NULL_",char1]` is the cost value of inserting it. When an operation is not defined in the cost_mat, it is set 0 when the two symbols are the same, otherwise 1.
#' @param delim The delimiter separating atomic symbols.
#' @param squareform Whether to return a dataframe in squareform.
#' @param symmetric Whether the result matrix is symmetric. This depends on whether the `cost_mat` is symmetric.
#' @param parallel Whether to parallelize the computation.
#' @param n_threads The number of threads is used to parallelize the computation. Only meaningful if `parallel` is TRUE.
#' @return A dataframe in long table form if `squareform` is FALSE, otherwise in squareform. If `symmetric` is TRUE, the long table form has \eqn{C_n^2} rows, otherwise \eqn{n^2} rows.
#' @examples
#' df <- as.data.frame(rbind(a=c("pʰ_l_i_z̥","k_o_l"),b=c("pʰ_l̥_i_z̥", "k_ɑ_lˠ")))
#' cost.mat <- data.frame()
#' result <- pw_edit_dist(df, cost_mat=cost.mat, delim="_")
#' result <- pw_edit_dist(df, cost_mat=cost.mat, delim="_", squareform=TRUE)
#' result <- pw_edit_dist(df, cost_mat=cost.mat, delim="_", parallel=TRUE, n_threads=4)
pw_edit_dist <- function(data, cost_mat = NULL, delim = "", squareform = FALSE, symmetric = TRUE, parallel = FALSE, n_threads = 2L) {
    .Call(`_lingdist_pw_edit_dist`, data, cost_mat, delim, squareform, symmetric, parallel, n_threads)
}

#' Compute PMI distance between all row pairs of a dataframe
#'
#' Compute PMI (Pointwise Mutual Information) distance between all row pairs of a dataframe.
#'
#' @param data DataFrame with n rows and m columns indicating there are n languages or dialects to involve in the calculation and there are at most m words to base on, in which the rownames are the language ids.
#' @param delim The delimiter separating atomic symbols.
#' @param squareform Whether to return a dataframe in squareform.
#' @param parallel Whether to parallelize the computation.
#' @param n_threads The number of threads is used to parallelize the computation. Only meaningful if `parallel` is TRUE.
#' @param max_epochs Maximum number of epochs for EM algorithm.
#' @param tol Tolerance for convergence.
#' @param alignment_max_paths Maximum number of paths to consider in alignment. There may be multiple optimal alignment paths between two strings; this parameter limits how many of them are considered when updating the cost matrix in each EM epoch.
#' @param verbose Whether to print more detailed computation messages, useful for tracking long computations and debugging.
#' @return A list containing the following components:
#' \item{result}{A dataframe of distances, either in long table form or square form.}
#' \item{cost}{The final cost matrix used for distance calculation. Note: this is NOT the cost matrix after the last iteration, but the one before that, which is used to compute the final distances. That is, when you finished the iteration after 10 epochs, the cost matrix used to compute distances is actually the one being updated after the 9th epoch.}
#' \item{sum_diff}{The sum of absolute differences between the cost matrices of the last two iterations.}
#' \item{mean_diff}{The mean of absolute differences between the cost matrices of the last two iterations.}
#' @examples
#' df <- as.data.frame(rbind(a=c("pʰ_l_i_z̥","k_o_l"),b=c("pʰ_l̥_i_z̥", "k_ɑ_lˠ")))
#' result <- pw_pmi_dist(df, delim="_")
#' result <- pw_pmi_dist(df, delim="_", squareform=TRUE)
#' result <- pw_pmi_dist(df, delim="_", parallel=TRUE, n_threads=4)
pw_pmi_dist <- function(data, delim = "", squareform = FALSE, parallel = FALSE, n_threads = 4L, max_epochs = 20L, tol = 1e-4, alignment_max_paths = 3L, verbose = TRUE) {
    .Call(`_lingdist_pw_pmi_dist`, data, delim, squareform, parallel, n_threads, max_epochs, tol, alignment_max_paths, verbose)
}

#' Compute Weighted Jaccard Distance between all row pairs of a dataframe
#'
#' Compute Weighted Jaccard Distance (WJD) between all row pairs of a dataframe. This metric is suitable for categorical data with hierarchical structure and multiple forms.
#' For example, a cell value "A_2_a#A_3#B_5_c" indicates there are 3 word forms for this lexical item. The first form "A_2_a" belongs to category A, subcategory 2, and sub-subcategory a. The second form "A_3" belongs to category A and subcategory 3. The third form "B_5_c" belongs to category B, subcategory 5, and sub-subcategory c. The delimiters can be customized via `form_delim` and `cate_delim`.
#'
#' @param data DataFrame with n rows and m columns indicating there are n languages or dialects to involve in the calculation and there are at most m words to base on, in which the rownames are the language ids.
#' @param cate_level_weights Numeric vector of weights for different levels of categories for a single word form. For example, if a word form is "A_2_a", the first weight applies to "A", the second to "2", and the third to "a". If not provided, default weights are used.
#' @param multi_form_weights Numeric vector of weights for different word forms of a single lexical item (ordered). For example, if a lexical item is "A_2_a#A_3#B_5_c", the first weight applies to "A_2_a", the second to "A_3", etc. If not provided, default weights are used.
#' @param form_delim The delimiter separating different word forms of a single lexical item. Default is "#".
#' @param cate_delim The delimiter separating different levels of categories within a word form. Default is "_".
#' @param squareform Whether to return a dataframe in squareform.
#' @param parallel Whether to parallelize the computation.
#' @param n_threads The number of threads is used to parallelize the computation. Only meaningful if `parallel` is TRUE.
#' @return A dataframe in long table form if `squareform` is FALSE, otherwise in squareform.
#' @examples
#' df <- as.data.frame(rbind(a=c("A_1#B_2","C_3"),b=c("A_1","C_3_x")))
#' result <- pw_wjd(df, form_delim="#", cate_delim="_")
pw_wjd <- function(data, cate_level_weights = NULL, multi_form_weights = NULL, form_delim = "#", cate_delim = "_", squareform = FALSE, parallel = FALSE, n_threads = 2L) {
    .Call(`_lingdist_pw_wjd`, data, cate_level_weights, multi_form_weights, form_delim, cate_delim, squareform, parallel, n_threads)
}

#' Generate a default cost matrix
#'
#' Generate a default cost matrix containing all possible characters in the raw data with all diagonal values set to 0 and others set to 1. This avoids constructing the matrix from scratch.
#'
#' @param data DataFrame to be computed.
#' @param delim The delimiter separating atomic symbols.
#' @return Cost matrix containing all possible characters in the raw data with all diagonal values set to 0 and others set to 1.
#' @examples
#' df <- as.data.frame(rbind(a=c("pʰ_l_i_z̥","k_o_l"),b=c("pʰ_l̥_i_z̥", "k_ɑ_lˠ")))
#' default.cost <- generate_default_cost_matrix(df, "_")
generate_default_cost_matrix <- function(data, delim = "") {
    .Call(`_lingdist_generate_default_cost_matrix`, data, delim)
}

#' Convert long table to square form
#'
#' Convert a distance dataframe in long table form to a square matrix form.
#'
#' @param data Dataframe in long table form. The first and second columns are labels and the third column stores the distance values.
#' @param symmetric Whether the distance matrix is symmetric (if cost matrix is not, then the distance matrix is also not).
#' @return Dataframe in square matrix form, rownames and colnames are labels. If the long table only contains \eqn{C_n^2} rows and `symmetric` is set to FALSE, then only lower triangle positions in the result are filled.
#' @examples
#' data <- as.data.frame(list(chars1=c("a","a","b"),chars2=c("b","c","c"),dist=c(1,2,3)))
#' mat <- long2squareform(data)
long2squareform <- function(data, symmetric = TRUE) {
    .Call(`_lingdist_long2squareform`, data, symmetric)
}

